<!DOCTYPE html>
<html lang="en">
<head>
    @@include('layout/meta.html', { "title" : "基礎JS" })
</head>
<body>
    <!-- header -->
    @@include('layout/header.html')
    <!-- header end -->
    <a href="https://blog.csdn.net/qq_35721888/article/details/106647403?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-106647403-blog-105144514.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-106647403-blog-105144514.pc_relevant_default&utm_relevant_index=1">參考題目連結</a>

    <div id="app">
        <section class="question">
            <div class="container">
                <base-question v-for="(issueExam,index) in questionObject" :issue-exam="questionObject[index]" :key="issueExam.id"></base-question>
            </div>
        </section>
    </div>
    <script>
        let baseQuestion = Vue.component('base-question',{
            props: ['issueExam'],
            template:`<div>
                <h2 class="ms_4 me_1">{{issueExam.numId}}</h2>
                <pre><code class="me_1">{{issueExam.quesTion}}</code></pre>
                <pre><code class="me_1" v-if="issueExam.consoleLog">{{issueExam.consoleLog}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods">{{issueExam.solMethods}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog2">{{issueExam.consoleLog2}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods2">{{issueExam.solMethods2}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog3">{{issueExam.consoleLog3}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods3">{{issueExam.solMethods3}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog4">{{issueExam.consoleLog4}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods4">{{issueExam.solMethods4}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog5">{{issueExam.consoleLog5}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods5">{{issueExam.solMethods5}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog6">{{issueExam.consoleLog6}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods6">{{issueExam.solMethods6}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog7">{{issueExam.consoleLog7}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods7">{{issueExam.solMethods7}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog8">{{issueExam.consoleLog8}}</code></pre>
                <p class="me_1" v-if="issueExam.solMethods8">{{issueExam.solMethods8}}</p>
                <pre><code class="me_1" v-if="issueExam.consoleLog9">{{issueExam.consoleLog9}}</code></pre>
                <p class="me_4" v-if="issueExam.solMethods9">{{issueExam.solMethods9}}</p>
                <a v-if="issueExam.hrefLink" :href="issueExam.hrefLink">參考連結</a>
                </div>`,
        })
        new Vue ({
            el: '#app',
            data:{
                questionObject:[
                    {
                        numId: `題目：1`,
                        quesTion: `if ( false ) { 
    var a = 1; let b = 2; 
} 
console.log(a); 
console.log(b);`,
                        consoleLog: `a undefined未明確定義; b is not defined`,
                        solMethods: `解析 : 因為if層級高，a進不去=1，但是var a 屬於全域變數，而let b 為區域變數，not defined。`
                    },
                    {
                        numId: `題目：2`,
                        quesTion: `var a = 1;
if ( true ) {
console.log(a);
let a = 2;
}`,
                        consoleLog: `Cannot access 'a' before initialization`,
                        solMethods: `解析 : 因為if 提升比var高，先執行，到console.log(a) => 出現還沒執行這一段之前你不能使用這個變數。`
                    },
                    {
                        numId: `題目：3`,
                        quesTion: `var a = {n:1};
var b = a;
a.x = a = {n:2};
console.log(a.n,b.n);
console.log(a.x,b.x);`,
                        consoleLog: `2 1 ; undefined object{n:2}`,
                        solMethods: `解析 : var a.x =>a擁有一個屬性x;先執行;
a =物件{n:1} b = a =物件{n:1}且 帶有 a.x =擁有x屬性;
a = 物件{n:2}(賦值由右至左，創建一個新的a)
a.x= a 物件{n:2}
最後 a.n=2; b.n=1; a.x=undefined; b.x=物件{n:2};`,
                        hrefLink: `https://chowdera.com/2022/03/202203110647531104.html`
                    },
                    {
                        numId: `題目：4`,
                        quesTion: `console.log(c);
var c;
function c(a) {
    console.log(a);
    var a = 3;
    function a(){
    }
}
c(2);`,
                        consoleLog: `function c(){
    console.log(a);
    var c = 3;
    function a(){
    }
}

function a(){
}`,
                        solMethods: `解析 : 變數提升也有優先級, 函式聲明 > arguments > 變數聲明`,
                    },
                    {
                        numId: `題目：5`,
                        quesTion: `var c = 1
function c(c) {
    console.log(c);
    var c = 3;
}
console.log(c);
c(2);
`,
                        consoleLog: `1

TypeError: c is not a function`,
                        solMethods: `解析 : 由於函式聲明會提升,當函式外的console.log(c)執行時,c已經被賦值為1。因此,執行c(2)時會抛出TypeError,因為1不是函式。  執行順序:function c => var c = 1 => console.log(c)(出現 1) =>c(2)(出現error);`,
                        hrefLink:`https://segmentfault.com/a/1190000013562979`,
                    },
                    {
                        numId: `題目：6`,
                        quesTion: `var name = 'erdong';
(function () {
    if (typeof name === 'undefined') {
        var name = 'chen'
        console.log(name)
    } else {
        console.log(name)
    }
})();`,
                        consoleLog: `chen;

以下是說明順序=>
var name = 'erdong';
(function () {
    var name;  // 變數name會提升到當前作用域頂部
    if (typeof name === 'undefined') {
        name = 'chen'
        console.log(name)
    } else {
        console.log(name)
    }
})();
                        
`,
                        solMethods: `解析 : 所以會執行if中的console.log(name)`,
                    },
                    {
                        numId: `題目：7`,
                        quesTion: `var a = 10;  
function test() {  
    a = 100;  
    console.log(a);  
    console.log(this.a);  
    var a;  
    console.log(a); 
}
test();`,
                        consoleLog: `// 輸出

100
10
100
`,
                        solMethods: `解析 : test()為函式獨立調用,作用域中的this绑定為全局對象window(若是使用箭頭函式，才可以指向function裡的100)。

test函式執行時,var a被提升到了作用域頂部,因此函式作用域中存在一個變數a。所以在函式中訪問的a都是局部作用域中的a。`,
                    },
                    {
                        numId: `題目：8`,
                        quesTion: `if (!(a in window)) {
    var a = 1;
}
console.log(a)
`,
                        consoleLog: `// 輸出
undefined`,
                        solMethods: `解析 : 由於if後的{}不會產生塊級作用域(不包含let,const時),此時的偽代碼為:`,
                        consoleLog2:`var a;
if (!(a in window)) {
    a = 1;
}
console.log(a);`,
                        solMethods2:`var a相當於window.a。因此!(a in window)轉成布林值為false,不會執行a = 1。所有console.log(a)輸出undefined。`,
                        quesTion: `if(!(a in window)){
var a = 1;
}
console.log(a)`,
                        consoleLog: `// 輸出

undefined

以下是說明順序=>
var a;
if(!(a in window)){
    a=1;
}
console.log(a);
`,
                        solMethods: `解析 :由於if後的{}不會產生區塊作用域(不包含let,const時),裡頭var a相當於全域window.a。因此!(a in window)轉成布林值為false,不會執行a = 1。所以console.log(a)輸出undefined。`,
                    },
                    {
                        numId: `題目：9`,
                        quesTion: `var a = 1

function c(a, b) {
    console.log(a)
    a = 2
    console.log(a)
}
c()
`,
                        consoleLog: `//輸出

undefined 

2
`,
                        solMethods: `跟第4题類似。`,
                        hrefLink:`https://segmentfault.com/a/1190000013562979`,

                    },
                    {
                        numId: `題目：10`,
                        quesTion: `var val=1;
var obj={
    val:2,
    del:function(){
        console.log(this);                    
        this.val*=2
        console.log(val) 
    }
}

obj.del();
`,
                        consoleLog: `// 輸出
obj(指向的值)=>
{val: 2, del: ƒ}
del: ƒ ()
val: 4
[[Prototype]]: Object

1
                        
`,
                        solMethods: `當通過obj.del()調用del函式時,del函式作用域中的this绑定為obj。
在函式作用域中訪問val時,由於del:函式中並沒有變數val,故this.val(指的是obj.val)*=2=4,但實際上console.log(val)訪問的是全局作用域中的val,即 1。

這裡考察的是this的指向,一定要熟练掌握。`
                    },
                    {
                        numId: `題目：11`,
                        quesTion: `var name = "erdong"
var object = {
    name: "chen",
    getNameFunc: function () {
        return function () {
            return this.name;
        }
    }
}
console.log(object.getNameFunc()());
`,
                        consoleLog: `// 輸出

erdong
`,
                        solMethods: `object.getNameFunc()(),先執行object.getNameFunc()返回一個函式:`,
                        consoleLog2: `function () {
    return this.name;
}`,
                        solMethods2: `返回的函式再執行,相當於`,
                        consoleLog3: `(function () {
    return this.name;
})();`,
                        solMethods3: `此時的this绑定為window。因此輸出全局變數name的值erdong。第一個function如果有this.name會輸出chen，但是第二個會是訪問全局`,
                    },
                    {
                        numId: `題目：12`,
                        quesTion: `var name = "erdong"
var object = {
    name: "chen",
    getNameFunc: function () {
        var that = this;
        return function () {
            return that.name;
        }
    }
}
console.log(object.getNameFunc()());
                        
`,
                        consoleLog: `//輸出
chen
`,
                        solMethods: `object.getNameFunc()執行時,此時getNameFunc中的this绑定為object,因此that = object。object.getNameFunc()返回的函式再執行時,產生閉包,因此返回的函式也能訪問到外層作用域中的變數that,因此object.name為object.name,即 chen。
`,
                    },
                    {
                        numId: `題目：13`,
                        quesTion: `(function() {
  var a = b = 3;
})();
console.log(typeof a === 'undefined');
console.log(typeof b === 'undefined');
`,
                        consoleLog: `// 輸出

true

false
`,
                        solMethods: `首先要明白a = b = 3是怎样執行的,偽代碼:`,
                        consoleLog2:`賦值順序=>
b = 3;
var a = b;
`,
                        solMethods2:`因此在自執行函式執行時,b由於為經var等操作符聲明,因為為全局變數。a為函式作用域中的變數。因此在外面訪問a和b時,其值分别為ReferenceError: a is not defined和3。但是typeof檢測未聲明的變數不會抛出錯誤,會返回'undefined'。因此typeof a和typeof b分别返回'undefined'和'number'。
                        b=3為全域，因為前面沒有用var宣告，而var a = b不是全域，所以a出不來外面，全域供大家使用，區域不供全域使用，即使是var在function裡也是區域。`,
                        hrefLink:`https://ithelp.ithome.com.tw/articles/10234400`,
                    },
                    {
                        numId: `題目：14`,
                        quesTion: `var a = 6;
setTimeout(function () {
    a = 666;
}, 0)
console.log(a);
`,
                        consoleLog: `//輸出

6
`,
                        solMethods: `setTimeout為宏任務(macro-task)。即使設置延遲為0ms,也是等待微任務(micro-task)執行完才會執行。因此console.log(a)輸出 6`,
                        hrefLink:`https://www.readfog.com/a/1634820472516481024`,
                    },
                    {
                        numId: `題目：15`,
                        quesTion: `function fn1() {
    var a = 2
    function fn2 () {
      a++
      console.log(a)
    }
    return fn2
}
var f = fn1()
f()
f()
`,
                        consoleLog: `// 輸出

3
4
`,
                        solMethods: `由於fn1函式執行後返回函式fn2,此時產生了閉包。因此fn2中a訪問的是fn1作用域中的變數a,因此第一次a++,之後a為3,第二次之後a為4。`
                    },
                    {
                        numId: `題目：16`,
                        quesTion: `var a = (function(foo){
    return typeof foo.bar;
})({foo:{bar:1}});

console.log(a);
`,
                        consoleLog: `//輸出

undefined
`,
                        solMethods: `實参foo的值為{foo:{bar:1},因此typeof foo.bar為undefined。

typeof foo.foo.bar為number。`
                    },
                    {
                        numId: `題目：17`,
                        quesTion: `function f(){
    return f;
}
console.log(new f() instanceof f);
                        
`,
                        consoleLog: `//輸出

false
`,
                        solMethods: `由於構造函式f的返回值為f。因此new f()的值為f。所以console.log(new f() instanceof f)為console.log(f instanceof f),即 false。`
                    },
                    {
                        numId: `題目：18`,
                        quesTion: `function A () {
}
A.prototype.n = 1

var b = new A();

A.prototype = {
    n: 2,
    m: 3
}
var c = new A()

console.log(b.n, b.m);
console.log(c.n, c.m);
`,
                        consoleLog: `// 輸出

1,undefined

2,3
                        
`,
                        solMethods: `var b = new A(); 實例化b時,A的prototype為`,
                        consoleLog2: `A.prototype = {
    constructor:A,
    n:1
}
`,
                        solMethods2:`當訪問b.n和b.m時,通過原型鏈找到A.prototype指向的對象上,即b.n = 1,b.m = undefined。

var c = new A(); 實例化c時,A的prototype為`,
                        consoleLog3: `A.prototype = {
    n: 2,
    m: 3
}
`,
                        solMethods3:`當訪問a.n和a.m時,通過原型鏈找到A.prototype指向的對象上,此時A.prototype重寫,因此a.n = 2,b.m = 3。`,
                    },
                    {
                        numId: `題目：19`,
                        quesTion: `var F = function(){}
var O = {};
Object.prototype.a = function(){
    console.log('a')
}
Function.prototype.b = function(){
    console.log('b')
}
var f = new F()

F.a();  
F.b();  
O.a();
O.b();  
`,
                        consoleLog: `// 輸出

a
b
a
TypeError: o.b is not a function
                        
`,
                        solMethods: `F為函式,它也能訪問Object原型上的方法,O為對象,不能訪問Function原型上的方法。
F的原型鏈為:`,
                        consoleLog2:`F => F.__proto__ => Function.prototype => Function.prototype.__proto__ => Object.prototype
`,
                        solMethods2: `由於Object.prototype在F的原型鏈上,所以F能訪問Object.prototype上的属性和方法。即: F.a(),F.b()能正常訪問。

O的原型鏈為:`,
                        consoleLog3:`O => O.__proto__ => Object.prototype
`,
                        solMethods3:`由於Function.prototype不在O的原型鏈上,因此O不能訪問Function.prototype上的方法,即O.b()抛出錯誤。

如果你對原型和原型鏈掌握的好,試著理解下面的案例:`,
                        consoleLog4:`console.log(Object instanceof Function);

console.log(Function instanceof Object);

console.log(Function instanceof Function);
`,
                    },
                    {
                        numId: `題目：20`,
                        quesTion: `function Person() {
    getAge = function () {
        console.log(10)
    }
    return this
}

Person.getAge = function () {
    console.log(20)
}

Person.prototype.getAge = function () {
    console.log(30)
}

var getAge = function () {
    console.log(40)
}

function getAge() {
    console.log(50)
}


Person.getAge();
getAge();
Person().getAge();
new Person.getAge();
getAge();
new Person().getAge();
`,
                        consoleLog: `// 輸出

20
40
10
20
10
30
`,
                        solMethods: `Person.getAge();此時執行的是Person函式上getAge方法。`,
                        consoleLog2:`Person.getAge = function () {
    console.log(20)
}
`,
                        solMethods2:`所以輸出:20。getAge();此時執行的是全局中的getAge方法。此時全局getAge方法為:`,
                        consoleLog3:`function () {
    console.log(40)
}`,
                        solMethods3:`所以輸出:40。Person().getAge();由於 Person() 單獨執行所以,作用域中的 this 绑定為 window, 相當於 window..getAge()。同上,執行的都是全局 getAge 方法,但是 Person 執行時,内部執行了`,
                        consoleLog4:`getAge = function () {
    console.log(10)
}`,
                        solMethods4:`因此全局getAge方法現在為:`,
                        consoleLog5:`function () {
    console.log(10)
}`,
                        solMethods5:`所以輸出:10。new Person.getAge();此時相當於實例化Person.getAge這個函式,偽代碼:`,
                        consoleLog6:`var b = Person.getAge;
new b();
`,
                        solMethods6:`所以輸出:20。getAge();執行全局getAge方法,由於在Person().getAge()執行時把全局getAge方法賦值為:`,
                        consoleLog7:`function () {
    console.log(10)
}`,
                        solMethods7:`所以輸出:10。new Person().getAge();此時調用的是Person原型上的getAge方法:`,
                        consoleLog8:`Person.prototype.getAge = function () {
    console.log(30)
}`,
                        solMethods8:`所以輸出:30。這裡要注意:1.變數提升及提升後再賦值。2.調用構造函式時,带()和不带()的區别。`,
                    },
                    {
                        numId: `題目：21`,
                        quesTion: `console.log(false.toString()); 
console.log([1, 2, 3].toString()); 
console.log(1.toString()); 
console.log(5..toString());
`,
                        consoleLog: `// 輸出

'false'
'1,2,3'
Uncaught SyntaxError: Invalid or unexpected token
'5'
`,
                        solMethods: `當執行1.toString();時,由於1.也是有效數字,因此此時變成(1.)toString()。沒有用.調用toString方法,因此抛出錯誤。

正确的應该是:`,
                        consoleLog2:`1..toString();
1 .toString();
(1).toString();
`,
                    },
                    {
                        numId: `題目：22`,
                        quesTion: `console.log(typeof NaN === 'number');
`,
                        consoleLog: `//輸出

true
`,
                        solMethods: `NaN為不是數字的數字。虽然它不是數字,但是它也是數字類型。`
                    },
                    {
                        numId: `題目：23`,
                        quesTion: `console.log(1 + "2" + "2");

console.log(1 + +"2" + "2");

console.log(1 + -"1" + "2");

console.log(+"1" + "1" + "2"); 

console.log( "A" - "B" + "2"); 

console.log( "A" - "B" + 2); 
`,
                        consoleLog: `//輸出

'122'
'32'
'02'
'112'
'NaN2'
NaN
`,
                        solMethods: `首先要明白兩點:`,
                        solMethods2:`+a,會把a轉換為數字。-a會把a轉換成數字的負值(如果能轉換為數字的话,否則為NaN)。字符串與任何值相加都是字符串拼接。`,
                        solMethods3:`console.log(1 + "2" + "2");簡單的字符串拼接,即结果為:'122'。`,
                        solMethods4:`console.log(1 + +"2" + "2");這裡相當於console.log(1 + 2 + "2");,然後再字符串拼接。即结果為:'32'。`,
                        solMethods5:`console.log(1 + -"1" + "2");這裡相當於console.log(1 + -1 + "2");,然後再字符串拼接。即结果為:'02'。`,
                        solMethods6:`console.log(+"1" + "1" + "2");這裡相當於console.log(1 + "1" + "2");,然後再字符串拼接。即结果為:'112'。`,
                        solMethods7:`console.log( "A" - "B" + "2");,由於'A' - 'B' = NaN,所以相當於console.log( NaN + "2");, 然後再字符串拼接。即结果為:'NaN2'。`,
                        solMethods8:`console.log( "A" - "B" + 2);同上,相當於console.log(NaN + 2),由於NaN+任何值還是NaN,即结果為:NaN。`,
                    },
                    {
                        numId: `題目：24`,
                        quesTion: `var a = 666;
console.log(++a);
console.log(a++);
`,
                        consoleLog: `// 輸出

666
668
`,
                        solMethods: `a++先執行取值操作,在執行+1。 此時輸出666,随後a的值變為667。`,
                        solMethods2:`++a先執行+1在執行取值操作。 此時a的值為667 + 1 = 668。`,
                        solMethods3:`--a和a--同理。`,
                        solMethods4:`使用這類運算符時要注意:`,
                        solMethods5:`1）這裡的++、--不能用作於常量。比如`,
                        consoleLog6:`1++; // 抛出錯誤`,
                        solMethods6:`2）如果a不是數字類型,會首先通過Number(a),將a轉換為數字。再執行++等運算。`,
                    },
                    {
                        numId: `題目：25`,
                        quesTion: `console.log(typeof a);
function a() {}
var a;
console.log(typeof a);
`,
                        consoleLog: `// 輸出

'function'
'function'
`,
                        solMethods: `跟第4题類似。函式會優先於變數聲明提前。因此會忽略var a。`
                    },
                    {
                        numId: `題目：26`,
                        quesTion: `var a;
var b = 'undefined';
console.log(typeof a);
console.log(typeof b);
console.log(typeof c);
                        
`,
                        consoleLog: `// 輸出
'undefined'
'string'
'undefined'
`,
                        solMethods: `a為聲明未賦值,默認為undefined,b的值為字符串'undefined',c為未定義。`,
                        solMethods2:`typeof一個未定義的變數時,不會抛出錯誤,會返回'undefined'。注意typeof返回的都是字符串類型。`,
                    },
                    {
                        numId: `題目：27`,
                        quesTion: `var x = 1;
if(function f(){}){
    x += typeof f;
}
 
console.log(x);
`,
                        consoleLog: `//輸出

1undefined
`,
                        solMethods: `function f(){}當做if條件判斷,其隱式轉換後為true。`,
                        solMethods2:`但是在()中的函式不會聲明提升,因此f函式在外部是不存在的。`,
                        solMethods3:`因此typeof f = 'undefined',所以x += typeof f,相當於x = x + 'undefined'為'1undefined'。`,
                    },
                    {
                        numId: `題目：28`,
                        quesTion: `var str = "123abc";
console.log(typeof str++);
`,
                        consoleLog: `// 輸出

'number'
`,
                        solMethods: `在24题解析時提到,使用++運算符時(無論是前置還是後置),如果變數不是數字類型,會首先用Number()轉換為數字。`,
                        solMethods2:`因此typeof str++相當於typeof Number(str)++。由於後置的++是先取值後計算,因此相當於typeof Number("123abc")。`,
                        solMethods3:`即typeof NaN,所以輸出'number'。`,
                    },
                    {
                        numId: `題目：29`,
                        quesTion: `console.log('b' + 'a' + +'a'+'a');
`,
                        consoleLog: `// 輸出

baNaNa
`,
                        solMethods: `'b' + 'a' + +'a'+'a'相當於'ba' + +'a'+'a',+'a'會將'a'轉換為數字類型,即+'a' = NaN。`,
                        solMethods2:`所以最终得到'ba' + NaN +'a',通過字符串拼接,结果為:baNaNa。`,
                    },
                    {
                        numId: `題目：30`,
                        quesTion: `var obj = {n: 1};
function fn2(a) {
    a.n = 2;
}
fn2(obj);
console.log(obj.n);
`,
                        consoleLog: `// 輸出

4
2
2
`,
                        solMethods: `函式傳遞参數時,如果是基本類型為值傳遞,如果是引用類型,為引用傳遞。`,
                        solMethods2:`因此實参a和obj指向對象的一個引用。`,
                        solMethods3:`當執行a.n,實際上共同引用的對象修改了,添加了個n属性,因此obj.n為2。`,
                    },
                    {
                        numId: `題目：31`,
                        quesTion: `var x = 10;
function fn() {
    console.log(x);
}
function show(f) {
    var x = 20;
    f();
}
show(fn);
`,
                        consoleLog: `// 輸出

10
`,
                        solMethods: `JavaScript採用的是詞法作用域,它規定了函式内訪問變數時,查找變數是從函式聲明的位置向外層作用域中查找,而不是從調用函式的位置開始向上查找。`,
                        solMethods2:`因此fn函式内部訪問的x是全局作用域中的x,而不是show函式作用域中的x。`,
                    },
                    {
                        numId: `題目：32`,
                        quesTion: `Object.prototype.bar = 1; 
var foo = {
    goo: undefined
};

console.log(foo.bar);
console.log('bar' in foo);

console.log(foo.hasOwnProperty('bar'));
console.log(foo.hasOwnProperty('goo'));
`,
                        consoleLog: `//輸出

1
true
false
true
                        
`,
                        solMethods: `in操作符:檢測指定對象(右邊)原型鏈上是否有對應的属性值。`,
                        solMethods2:`hasOwnProperty方法:檢測指定對象自身上是否有對應的属性值。`,
                        solMethods3:`兩者的區别在於in會查找原型鏈,而hasOwnProperty不會。`,
                        solMethods4:`案例中對象foo自身上存在goo属性,而它的原型鏈上存在bar属性。`,
                        solMethods5:`通過這個例子要注意如果要判斷foo上是否有属性goo,不能簡單的通過if(foo.goo){}判斷,因為goo的值可能為undefined或者其他可能隱式轉換為false的值。`,
                    },
                    {
                        numId: `題目：33`,
                        quesTion: `Object.prototype.bar = 1;

var foo = {
    moo: 2
};
for(var i in foo) {
    console.log(i); 
}
`,
                        consoleLog: `// 輸出

'moo'
'bar'
`,
                        solMethods: `for...in...遍歷對象上除了Symbol以外的可枚舉属性,包括原型鏈上的属性。`,
                    },
                    {
                        numId: `題目：34`,
                        quesTion: `function foo1() {
    return {
        bar: "hello"
    };
}
function foo2() {
    return 
    {
        bar: "hello"
    };
}
console.log(foo1());
console.log(foo2());
`,
                        consoleLog: `// 輸出

{ bar: "hello" }

undefined
`,
                        solMethods: `兩個函式唯一區别就是return後面跟的值,一個換行一個不換行。`,
                        solMethods2:`當我们書寫代碼時忘記在结尾書寫;時,JavaScript解析器會根據一定規則自動補上;。`,
                        consoleLog3:`return
{
    bar: "hello"
}
=> 會被解析成
return;
{
    bar: "hello"
};`,
                        solMethods3:`因此函式執行後會返回undefined。`,
                    },
                    {
                        numId: `題目：35`,
                        quesTion: `console.log((function(){ return typeof arguments; })());
`,
                        consoleLog: `// 輸出

'object'`,
                        solMethods: `arguments為類數组,類型為object。因此typeof arguments = 'object'。`
                    },
                    {
                        numId: `題目：36`,
                        quesTion: `console.log(Boolean(false));
console.log(Boolean('0'));
console.log(Boolean(''));
console.log(Boolean(NaN));
`,
                        consoleLog: `//輸出

false
true
false
fasle
`,
                        solMethods: `只有下面幾種值在轉換為布林值時為false:`,
                        consoleLog2:`+0,-0,NaN,false,'',null,undefined。`,
                        solMethods2:`除此之外的值在轉換為布林值的時候全部為true。`,
                    },
                    {
                        numId: `題目：37`,
                        quesTion: `console.log(Array(3));

console.log(Array(2,3));`,
                        consoleLog:`// 輸出

[empty × 3] 

[2,3]
`,
                        solMethods: `使用Array()創建數组時,要注意传入的值的類型和數量。`,
                    },
                    {
                        numId: `題目：38`,
                        quesTion: `console.log(0.1 + 0.2 == 0.3)；`,
                        consoleLog: `// 輸出

false
`,
                        solMethods: ``
                    },
                    {
                        numId: `題目：39`,
                        quesTion: `var a=[1, 2, 3];
console.log(a.join());
`,
                        consoleLog: `//輸出

1,2,3
`,
                        solMethods: `join方法如果省略参數,默認以,分隔。`
                    },
                    {
                        numId: `題目：40`,
                        quesTion: `var a = [3];
var b = [1];
console.log(a - b); 
                        
`,
                        consoleLog: `// 輸出

2
`,
                        solMethods: `在執行a - b時,a和b都要轉換為數字。`,
                        solMethods2:`首先a先轉換為字符串,[3] => [3].toString() => '3',然後Number(3) => 3。b同理。`,
                        solMethods3:`因此轉換之後為3 - 1 = 3。`,
                    },
                ],
            }
        })
    </script>
    <!-- script -->
    @@include('layout/script.html')
    <!-- script end -->
    <!-- 模組 -->
    <!-- <h1>1.</h1>
    <p>題目:<hr></p>
    <p>輸出:<br></p>
    <p>解析:<br></p>
    <script></script> -->
</body>
</html>